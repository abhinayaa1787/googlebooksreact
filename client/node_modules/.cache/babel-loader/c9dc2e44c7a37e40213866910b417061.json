{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/abhiaadhav/Desktop/BOOTCAMP/ASSIGNMENT/googlebooksreact/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar Document = require('../document');\n\nvar EmbeddedDocument = require('./embedded');\n\nvar ObjectId = require('./objectid');\n\nvar cleanModifiedSubpaths = require('../helpers/document/cleanModifiedSubpaths');\n\nvar get = require('../helpers/get');\n\nvar internalToObjectOptions = require('../options').internalToObjectOptions;\n\nvar utils = require('../utils');\n\nvar util = require('util');\n\nvar arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\n\nvar arrayParentSymbol = require('../helpers/symbols').arrayParentSymbol;\n\nvar arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\n\nvar arraySchemaSymbol = require('../helpers/symbols').arraySchemaSymbol;\n\nvar populateModelSymbol = require('../helpers/symbols').populateModelSymbol;\n\nvar _basePush = Array.prototype.push;\nvar validatorsSymbol = Symbol('mongoose#MongooseCoreArray#validators');\n/*!\n * ignore\n */\n\nvar CoreMongooseArray =\n/*#__PURE__*/\nfunction (_Array) {\n  _inherits(CoreMongooseArray, _Array);\n\n  function CoreMongooseArray() {\n    _classCallCheck(this, CoreMongooseArray);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CoreMongooseArray).apply(this, arguments));\n  }\n\n  _createClass(CoreMongooseArray, [{\n    key: \"$__getAtomics\",\n\n    /**\n     * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n     *\n     * If no atomics exist, we return all array values after conversion.\n     *\n     * @return {Array}\n     * @method $__getAtomics\n     * @memberOf MongooseArray\n     * @instance\n     * @api private\n     */\n    value: function $__getAtomics() {\n      var ret = [];\n      var keys = Object.keys(this[arrayAtomicsSymbol]);\n      var i = keys.length;\n      var opts = Object.assign({}, internalToObjectOptions, {\n        _isNested: true\n      });\n\n      if (i === 0) {\n        ret[0] = ['$set', this.toObject(opts)];\n        return ret;\n      }\n\n      while (i--) {\n        var op = keys[i];\n        var val = this[arrayAtomicsSymbol][op]; // the atomic values which are arrays are not MongooseArrays. we\n        // need to convert their elements as if they were MongooseArrays\n        // to handle populated arrays versus DocumentArrays properly.\n\n        if (utils.isMongooseObject(val)) {\n          val = val.toObject(opts);\n        } else if (Array.isArray(val)) {\n          val = this.toObject.call(val, opts);\n        } else if (val != null && Array.isArray(val.$each)) {\n          val.$each = this.toObject.call(val.$each, opts);\n        } else if (val != null && typeof val.valueOf === 'function') {\n          val = val.valueOf();\n        }\n\n        if (op === '$addToSet') {\n          val = {\n            $each: val\n          };\n        }\n\n        ret.push([op, val]);\n      }\n\n      return ret;\n    }\n    /*!\n     * ignore\n     */\n\n  }, {\n    key: \"$atomics\",\n    value: function $atomics() {\n      return this[arrayAtomicsSymbol];\n    }\n    /*!\n     * ignore\n     */\n\n  }, {\n    key: \"$parent\",\n    value: function $parent() {\n      return this[arrayParentSymbol];\n    }\n    /*!\n     * ignore\n     */\n\n  }, {\n    key: \"$path\",\n    value: function $path() {\n      return this[arrayPathSymbol];\n    }\n    /**\n     * Atomically shifts the array at most one time per document `save()`.\n     *\n     * ####NOTE:\n     *\n     * _Calling this multiple times on an array before saving sends the same command as calling it once._\n     * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n     *\n     *      doc.array = [1,2,3];\n     *\n     *      var shifted = doc.array.$shift();\n     *      console.log(shifted); // 1\n     *      console.log(doc.array); // [2,3]\n     *\n     *      // no affect\n     *      shifted = doc.array.$shift();\n     *      console.log(doc.array); // [2,3]\n     *\n     *      doc.save(function (err) {\n     *        if (err) return handleError(err);\n     *\n     *        // we saved, now $shift works again\n     *        shifted = doc.array.$shift();\n     *        console.log(shifted ); // 2\n     *        console.log(doc.array); // [3]\n     *      })\n     *\n     * @api public\n     * @memberOf MongooseArray\n     * @instance\n     * @method $shift\n     * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n     */\n\n  }, {\n    key: \"$shift\",\n    value: function $shift() {\n      this._registerAtomic('$pop', -1);\n\n      this._markModified(); // only allow shifting once\n\n\n      if (this._shifted) {\n        return;\n      }\n\n      this._shifted = true;\n      return [].shift.call(this);\n    }\n    /**\n     * Pops the array atomically at most one time per document `save()`.\n     *\n     * #### NOTE:\n     *\n     * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n     * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n     *\n     *      doc.array = [1,2,3];\n     *\n     *      var popped = doc.array.$pop();\n     *      console.log(popped); // 3\n     *      console.log(doc.array); // [1,2]\n     *\n     *      // no affect\n     *      popped = doc.array.$pop();\n     *      console.log(doc.array); // [1,2]\n     *\n     *      doc.save(function (err) {\n     *        if (err) return handleError(err);\n     *\n     *        // we saved, now $pop works again\n     *        popped = doc.array.$pop();\n     *        console.log(popped); // 2\n     *        console.log(doc.array); // [1]\n     *      })\n     *\n     * @api public\n     * @method $pop\n     * @memberOf MongooseArray\n     * @instance\n     * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n     * @method $pop\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"$pop\",\n    value: function $pop() {\n      this._registerAtomic('$pop', 1);\n\n      this._markModified(); // only allow popping once\n\n\n      if (this._popped) {\n        return;\n      }\n\n      this._popped = true;\n      return [].pop.call(this);\n    }\n    /*!\n     * ignore\n     */\n\n  }, {\n    key: \"$schema\",\n    value: function $schema() {\n      return this[arraySchemaSymbol];\n    }\n    /**\n     * Casts a member based on this arrays schema.\n     *\n     * @param {any} value\n     * @return value the casted value\n     * @method _cast\n     * @api private\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"_cast\",\n    value: function _cast(value) {\n      var populated = false;\n      var Model;\n\n      if (this[arrayParentSymbol]) {\n        populated = this[arrayParentSymbol].populated(this[arrayPathSymbol], true);\n      }\n\n      if (populated && value !== null && value !== undefined) {\n        // cast to the populated Models schema\n        Model = populated.options[populateModelSymbol]; // only objects are permitted so we can safely assume that\n        // non-objects are to be interpreted as _id\n\n        if (Buffer.isBuffer(value) || value instanceof ObjectId || !utils.isObject(value)) {\n          value = {\n            _id: value\n          };\n        } // gh-2399\n        // we should cast model only when it's not a discriminator\n\n\n        var isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;\n\n        if (!isDisc) {\n          value = new Model(value);\n        }\n\n        return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], true);\n      }\n\n      return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], false);\n    }\n    /**\n     * Internal helper for .map()\n     *\n     * @api private\n     * @return {Number}\n     * @method _mapCast\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"_mapCast\",\n    value: function _mapCast(val, index) {\n      return this._cast(val, this.length + index);\n    }\n    /**\n     * Marks this array as modified.\n     *\n     * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n     *\n     * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n     * @param {String} embeddedPath the path which changed in the embeddedDoc\n     * @method _markModified\n     * @api private\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"_markModified\",\n    value: function _markModified(elem, embeddedPath) {\n      var parent = this[arrayParentSymbol];\n      var dirtyPath;\n\n      if (parent) {\n        dirtyPath = this[arrayPathSymbol];\n\n        if (arguments.length) {\n          if (embeddedPath != null) {\n            // an embedded doc bubbled up the change\n            dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n          } else {\n            // directly set an index\n            dirtyPath = dirtyPath + '.' + elem;\n          }\n        }\n\n        parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);\n      }\n\n      return this;\n    }\n    /**\n     * Register an atomic operation with the parent.\n     *\n     * @param {Array} op operation\n     * @param {any} val\n     * @method _registerAtomic\n     * @api private\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"_registerAtomic\",\n    value: function _registerAtomic(op, val) {\n      if (op === '$set') {\n        // $set takes precedence over all other ops.\n        // mark entire array modified.\n        this[arrayAtomicsSymbol] = {\n          $set: val\n        };\n        cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);\n\n        this._markModified();\n\n        return this;\n      }\n\n      var atomics = this[arrayAtomicsSymbol]; // reset pop/shift after save\n\n      if (op === '$pop' && !('$pop' in atomics)) {\n        var _this = this;\n\n        this[arrayParentSymbol].once('save', function () {\n          _this._popped = _this._shifted = null;\n        });\n      } // check for impossible $atomic combos (Mongo denies more than one\n      // $atomic op on a single path\n\n\n      if (this[arrayAtomicsSymbol].$set || Object.keys(atomics).length && !(op in atomics)) {\n        // a different op was previously registered.\n        // save the entire thing.\n        this[arrayAtomicsSymbol] = {\n          $set: this\n        };\n        return this;\n      }\n\n      var selector;\n\n      if (op === '$pullAll' || op === '$addToSet') {\n        atomics[op] || (atomics[op] = []);\n        atomics[op] = atomics[op].concat(val);\n      } else if (op === '$pullDocs') {\n        var pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n\n        if (val[0] instanceof EmbeddedDocument) {\n          selector = pullOp['$or'] || (pullOp['$or'] = []);\n          Array.prototype.push.apply(selector, val.map(function (v) {\n            return v.toObject({\n              transform: false,\n              virtuals: false\n            });\n          }));\n        } else {\n          selector = pullOp['_id'] || (pullOp['_id'] = {\n            $in: []\n          });\n          selector['$in'] = selector['$in'].concat(val);\n        }\n      } else if (op === '$push') {\n        atomics.$push = atomics.$push || {\n          $each: []\n        };\n        atomics.$push.$each = atomics.$push.$each.concat(val);\n      } else {\n        atomics[op] = val;\n      }\n\n      return this;\n    }\n    /**\n     * Adds values to the array if not already present.\n     *\n     * ####Example:\n     *\n     *     console.log(doc.array) // [2,3,4]\n     *     var added = doc.array.addToSet(4,5);\n     *     console.log(doc.array) // [2,3,4,5]\n     *     console.log(added)     // [5]\n     *\n     * @param {any} [args...]\n     * @return {Array} the values that were added\n     * @memberOf MongooseArray\n     * @api public\n     * @method addToSet\n     */\n\n  }, {\n    key: \"addToSet\",\n    value: function addToSet() {\n      _checkManualPopulation(this, arguments);\n\n      var values = [].map.call(arguments, this._mapCast, this);\n      values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);\n      var added = [];\n      var type = '';\n\n      if (values[0] instanceof EmbeddedDocument) {\n        type = 'doc';\n      } else if (values[0] instanceof Date) {\n        type = 'date';\n      }\n\n      values.forEach(function (v) {\n        var found;\n        var val = +v;\n\n        switch (type) {\n          case 'doc':\n            found = this.some(function (doc) {\n              return doc.equals(v);\n            });\n            break;\n\n          case 'date':\n            found = this.some(function (d) {\n              return +d === val;\n            });\n            break;\n\n          default:\n            found = ~this.indexOf(v);\n        }\n\n        if (!found) {\n          [].push.call(this, v);\n\n          this._registerAtomic('$addToSet', v);\n\n          this._markModified();\n\n          [].push.call(added, v);\n        }\n      }, this);\n      return added;\n    }\n    /**\n     * Returns the number of pending atomic operations to send to the db for this array.\n     *\n     * @api private\n     * @return {Number}\n     * @method hasAtomics\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"hasAtomics\",\n    value: function hasAtomics() {\n      if (!utils.isPOJO(this[arrayAtomicsSymbol])) {\n        return 0;\n      }\n\n      return Object.keys(this[arrayAtomicsSymbol]).length;\n    }\n    /**\n     * Return whether or not the `obj` is included in the array.\n     *\n     * @param {Object} obj the item to check\n     * @return {Boolean}\n     * @api public\n     * @method includes\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(obj) {\n      return this.indexOf(obj) !== -1;\n    }\n    /**\n     * Return the index of `obj` or `-1` if not found.\n     *\n     * @param {Object} obj the item to look for\n     * @return {Number}\n     * @api public\n     * @method indexOf\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(obj) {\n      if (obj instanceof ObjectId) {\n        obj = obj.toString();\n      }\n\n      for (var i = 0, len = this.length; i < len; ++i) {\n        if (obj == this[i]) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * Helper for console.log\n     *\n     * @api public\n     * @method inspect\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return JSON.stringify(this);\n    }\n    /**\n     * Pushes items to the array non-atomically.\n     *\n     * ####NOTE:\n     *\n     * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n     *\n     * @param {any} [args...]\n     * @api public\n     * @method nonAtomicPush\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"nonAtomicPush\",\n    value: function nonAtomicPush() {\n      var values = [].map.call(arguments, this._mapCast, this);\n      var ret = [].push.apply(this, values);\n\n      this._registerAtomic('$set', this);\n\n      this._markModified();\n\n      return ret;\n    }\n    /**\n     * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n     *\n     * ####Note:\n     *\n     * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n     *\n     * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n     * @api public\n     * @method pop\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var ret = [].pop.call(this);\n\n      this._registerAtomic('$set', this);\n\n      this._markModified();\n\n      return ret;\n    }\n    /**\n     * Pulls items from the array atomically. Equality is determined by casting\n     * the provided value to an embedded document and comparing using\n     * [the `Document.equals()` function.](./api.html#document_Document-equals)\n     *\n     * ####Examples:\n     *\n     *     doc.array.pull(ObjectId)\n     *     doc.array.pull({ _id: 'someId' })\n     *     doc.array.pull(36)\n     *     doc.array.pull('tag 1', 'tag 2')\n     *\n     * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n     *\n     *     doc.subdocs.push({ _id: 4815162342 })\n     *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n     *\n     * Or we may passing the _id directly and let mongoose take care of it.\n     *\n     *     doc.subdocs.push({ _id: 4815162342 })\n     *     doc.subdocs.pull(4815162342); // works\n     *\n     * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n     *\n     * @param {any} [args...]\n     * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n     * @api public\n     * @method pull\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"pull\",\n    value: function pull() {\n      var values = [].map.call(arguments, this._cast, this);\n      var cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);\n      var i = cur.length;\n      var mem;\n\n      while (i--) {\n        mem = cur[i];\n\n        if (mem instanceof Document) {\n          var some = values.some(function (v) {\n            return mem.equals(v);\n          });\n\n          if (some) {\n            [].splice.call(cur, i, 1);\n          }\n        } else if (~cur.indexOf.call(values, mem)) {\n          [].splice.call(cur, i, 1);\n        }\n      }\n\n      if (values[0] instanceof EmbeddedDocument) {\n        this._registerAtomic('$pullDocs', values.map(function (v) {\n          return v._id || v;\n        }));\n      } else {\n        this._registerAtomic('$pullAll', values);\n      }\n\n      this._markModified(); // Might have modified child paths and then pulled, like\n      // `doc.children[1].name = 'test';` followed by\n      // `doc.children.remove(doc.children[0]);`. In this case we fall back\n      // to a `$set` on the whole array. See #3511\n\n\n      if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {\n        this._registerAtomic('$set', this);\n      }\n\n      return this;\n    }\n    /**\n     * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n     *\n     * @param {Object} [args...]\n     * @api public\n     * @method push\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"push\",\n    value: function push() {\n      if (this[arraySchemaSymbol] == null) {\n        return _basePush.apply(this, arguments);\n      }\n\n      _checkManualPopulation(this, arguments);\n\n      var values = [].map.call(arguments, this._mapCast, this);\n      values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol], undefined, undefined, {\n        skipDocumentArrayCast: true\n      });\n      var ret = [].push.apply(this, values);\n\n      this._registerAtomic('$push', values);\n\n      this._markModified();\n\n      return ret;\n    }\n    /**\n     * Alias of [pull](#types_array_MongooseArray-pull)\n     *\n     * @see MongooseArray#pull #types_array_MongooseArray-pull\n     * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n     * @api public\n     * @memberOf MongooseArray\n     * @instance\n     * @method remove\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.pull.apply(this, arguments);\n    }\n    /**\n     * Sets the casted `val` at index `i` and marks the array modified.\n     *\n     * ####Example:\n     *\n     *     // given documents based on the following\n     *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n     *\n     *     var doc = new Doc({ array: [2,3,4] })\n     *\n     *     console.log(doc.array) // [2,3,4]\n     *\n     *     doc.array.set(1,\"5\");\n     *     console.log(doc.array); // [2,5,4] // properly cast to number\n     *     doc.save() // the change is saved\n     *\n     *     // VS not using array#set\n     *     doc.array[1] = \"5\";\n     *     console.log(doc.array); // [2,\"5\",4] // no casting\n     *     doc.save() // change is not saved\n     *\n     * @return {Array} this\n     * @api public\n     * @method set\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(i, val) {\n      var value = this._cast(val, i);\n\n      this[i] = value;\n\n      this._markModified(i);\n\n      return this;\n    }\n    /**\n     * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n     *\n     * ####Example:\n     *\n     *     doc.array = [2,3];\n     *     var res = doc.array.shift();\n     *     console.log(res) // 2\n     *     console.log(doc.array) // [3]\n     *\n     * ####Note:\n     *\n     * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n     *\n     * @api public\n     * @method shift\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      var ret = [].shift.call(this);\n\n      this._registerAtomic('$set', this);\n\n      this._markModified();\n\n      return ret;\n    }\n    /**\n     * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n     *\n     * ####NOTE:\n     *\n     * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n     *\n     * @api public\n     * @method sort\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort() {\n      var ret = [].sort.apply(this, arguments);\n\n      this._registerAtomic('$set', this);\n\n      return ret;\n    }\n    /**\n     * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n     *\n     * ####Note:\n     *\n     * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n     *\n     * @api public\n     * @method splice\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"splice\",\n    value: function splice() {\n      var ret;\n\n      _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n      if (arguments.length) {\n        var vals = [];\n\n        for (var i = 0; i < arguments.length; ++i) {\n          vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));\n        }\n\n        ret = [].splice.apply(this, vals);\n\n        this._registerAtomic('$set', this);\n      }\n\n      return ret;\n    }\n    /*!\n     * ignore\n     */\n\n  }, {\n    key: \"toBSON\",\n    value: function toBSON() {\n      return this.toObject(internalToObjectOptions);\n    }\n    /**\n     * Returns a native js Array.\n     *\n     * @param {Object} options\n     * @return {Array}\n     * @api public\n     * @method toObject\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject(options) {\n      if (options && options.depopulate) {\n        options = utils.clone(options);\n        options._isNested = true;\n        return this.map(function (doc) {\n          return doc instanceof Document ? doc.toObject(options) : doc;\n        });\n      }\n\n      return this.slice();\n    }\n    /**\n     * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n     *\n     * ####Note:\n     *\n     * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n     *\n     * @api public\n     * @method unshift\n     * @memberOf MongooseArray\n     */\n\n  }, {\n    key: \"unshift\",\n    value: function unshift() {\n      _checkManualPopulation(this, arguments);\n\n      var values = [].map.call(arguments, this._cast, this);\n      values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);\n      [].unshift.apply(this, values);\n\n      this._registerAtomic('$set', this);\n\n      this._markModified();\n\n      return this.length;\n    }\n  }, {\n    key: \"isMongooseArray\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"validators\",\n    get: function get() {\n      return this[validatorsSymbol];\n    },\n    set: function set(v) {\n      this[validatorsSymbol] = v;\n    }\n  }]);\n\n  return CoreMongooseArray;\n}(_wrapNativeSuper(Array));\n\nif (util.inspect.custom) {\n  CoreMongooseArray.prototype[util.inspect.custom] = CoreMongooseArray.prototype.inspect;\n}\n/*!\n * ignore\n */\n\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n\n  for (var i = 0; i < docs.length; ++i) {\n    var arg = docs[i];\n\n    if (arg == null) {\n      return false;\n    }\n\n    var model = arg.constructor;\n\n    if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*!\n * ignore\n */\n\n\nfunction _checkManualPopulation(arr, docs) {\n  var ref = arr == null ? null : get(arr[arraySchemaSymbol], 'caster.options.ref', null);\n\n  if (arr.length === 0 && docs.length > 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr[arrayParentSymbol].populated(arr[arrayPathSymbol], [], _defineProperty({}, populateModelSymbol, docs[0].constructor));\n    }\n  }\n}\n\nmodule.exports = CoreMongooseArray;","map":null,"metadata":{},"sourceType":"script"}